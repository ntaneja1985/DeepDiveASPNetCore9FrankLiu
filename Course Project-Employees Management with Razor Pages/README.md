### How Anti-Forgery Tokens Work

Anti-forgery tokens are a security measure to prevent **Cross-Site Request Forgery (CSRF or XSRF)** attacks. A CSRF attack tricks an authenticated user into unknowingly submitting a malicious request to a web application.

The core idea is to ensure that a request (like submitting a form) was sent intentionally by a user from a page generated by your application, not from a malicious third-party site.

#### The Mechanism (Diagram)

The process involves two tokens: one sent in a **cookie** and another embedded as a **hidden field** in the form.

**1. Legitimate User Flow**

A user requests a page with a form. The server generates two tokens, sends one in the form's hidden field and the other in a cookie. When the user submits the form, both tokens are sent back. The server validates that they match.

```
       +-----------------+                                +-----------------+
       |     Browser     |                                |      Server     |
       +-----------------+                                +-----------------+
                |                                                  |
(1) GET /CreatePage  |                                                  |
       ------------------------------------------------------------>
                |                                                  |
                | (2) Returns HTML with:                             |
                |  - <input type="hidden" name="__RequestVerificationToken" value="TOKEN_A">
                |  - Sets Cookie: .AspNetCore.Antiforgery="TOKEN_B"  |
       <------------------------------------------------------------
                |                                                  |
                | User fills form and clicks "Submit"                |
                |                                                  |
(3) POST /CreatePage |                                                  |
    - Form Data (includes TOKEN_A)                                   |
    - Cookie (includes TOKEN_B)                                      |
       ------------------------------------------------------------>
                |                                                  |
                | (4) Server validates TOKEN_A == TOKEN_B            |
                |     If match -> Process Request                    |
                |     If no match -> Reject Request                  |
                |                                                  |
```

*Note: The actual implementation combines and encrypts these tokens, but the principle of matching a form value to a cookie value holds.*

**2. Foiled CSRF Attack Flow**

An attacker creates a malicious page that tries to submit a form to your server on behalf of a logged-in user. The user's browser will automatically send the authentication and anti-forgery cookies, but the attacker's form **cannot** contain the correct hidden field token.

```
       +-----------------+     +-------------------+     +-----------------+
       |     Browser     |     | Malicious Site    |     |   Your Server   |
       +-----------------+     +-------------------+     +-----------------+
                |                       |                         |
(1) User is logged into Your Server (has the cookie)              |
                |                       |                         |
(2) User visits Malicious Site                                    |
       ---------------------->          |                         |
                |                       |                         |
                | (3) Site has a hidden form that auto-submits      |
                |     to Your Server.                               |
                |                       |                         |
(4) POST /DeleteAccount (sends cookie, but MISSING the form token)
       ----------------------------------------------------------->
                |                       |                         |
                |                 (5) Server receives request.      |
                |                     Cookie token is present.    |
                |                     Form token is MISSING.      |
                |                     VALIDATION FAILS.           |
                |                     Request is REJECTED.        |
```


#### Code Examples (ASP.NET Core)

In modern ASP.NET Core, implementing this is straightforward.

**1. Generating the Token in the View**

As mentioned in the transcript, you can use an HTML helper. However, the standard `<form>` tag helper in Razor automatically includes the anti-forgery token for any form with `method="post"`.

```csharp
//_EmployeeDetails.cshtml

// This is the recommended, modern approach.
// The anti-forgery token is generated and added automatically.
<form method="post">
    <div>
        <label asp-for="Employee.Name"></label>
        <input asp-for="Employee.Name" class="form-control" />
    </div>
    <button type="submit">Save</button>
</form>

// This is the older HTML Helper approach mentioned in the transcript.
// It is still valid but less common now.
<form method="post">
    @Html.AntiForgeryToken()
    <div>
        <!-- form fields -->
    </div>
    <button type="submit">Save</button>
</form>
```

**2. Validating the Token on the Server**

* **For Razor Pages:** Protection is **enabled by default** for all POST handlers. You do not need to add any special attributes. The framework handles the validation automatically before your `OnPost()` method is executed.

```csharp
// Create.cshtml.cs (Razor Pages PageModel)

public class CreateModel : PageModel
{
    // No attribute is needed here. Validation is automatic for POST.
    public IActionResult OnPost()
    {
        if (!ModelState.IsValid)
        {
            return Page();
        }

        // ... process the valid request ...
        return RedirectToPage("./Index");
    }
}
```

* **For MVC Controllers:** You must explicitly add the `[ValidateAntiForgeryToken]` attribute to the action method that handles the POST request.

```csharp
// EmployeesController.cs (MVC Controller)

public class EmployeesController : Controller
{
    [HttpPost]
    [ValidateAntiForgeryToken] // This attribute is required for validation
    public IActionResult Create(EmployeeViewModel model)
    {
        // ... process the valid request ...
        return RedirectToAction("Index");
    }
}
```


### Interview Summary Table: Anti-Forgery (CSRF)

| Concept | Description | Key Points for Interviews |
| :-- | :-- | :-- |
| **The Problem: CSRF** | **Cross-Site Request Forgery (CSRF/XSRF)** is an attack where a malicious website tricks a user's browser into making an unwanted request to another site where the user is authenticated (e.g., submitting a form to transfer money or change a password). | The attack exploits the trust a site has in an authenticated user. The browser automatically sends authentication cookies with the request, making it appear legitimate to the server. |
| **The Solution: Anti-Forgery Token** | A unique, server-generated token used to verify that a request came from a form that the server itself created, not from a malicious third-party site. | It's a defense-in-depth security measure. It doesn't prove who the user is (that's authentication), but proves the user's *intent* to perform the action from your UI. |
| **How it Works** | The server generates two related tokens. One is sent as a cookie. The other is embedded as a hidden field in the HTML form. When the form is submitted, the server validates that the token from the form matches the token from the cookie. | A malicious site can't read or create the correct hidden form token, so the validation fails. The mechanism is a **cookie-to-header/form field** comparison. |
| **Implementation in ASP.NET Core** | **Generation (View):** The `<form method="post">` tag helper automatically generates and injects the hidden token field. The older `@Html.AntiForgeryToken()` helper also works. <br><br> **Validation (Server):** **Razor Pages** have protection enabled by default for POST handlers. **MVC Controllers** require the `[ValidateAntiForgeryToken]` attribute on the POST action method. | Mention both Razor Pages (default) and MVC (explicit attribute). Knowing the `<form>` tag helper handles it automatically is a key modern detail. |


### Key Interview Takeaways from the Transcript

* **Razor Pages vs. MVC Controllers**
    * Razor Pages combine the page's UI (`.cshtml`) and its server-side logic (`.cshtml.cs`) into a single unit, simplifying the structure compared to MVC's separate controllers, models, and views.
    * Page handlers like `OnGet()` and `OnPost()` in Razor Pages handle HTTP requests, which is more direct than the action methods in an MVC controller.
* **The Purpose of ViewModels**
    * A **ViewModel** is used when the data model from your database is not a perfect fit for what your UI needs to display.
    * **Use a ViewModel to:**

1. **Avoid Exposing Sensitive Data:** Prevent fields like passwords from being sent to the client.
2. **Provide Additional UI Data:** Combine data from multiple sources, like an `Employee` object and a list of `Departments` for a dropdown menu, into a single object for the view.
* **Model Binding in Razor Pages**
    * The `[BindProperty]` attribute is used on a property in your PageModel to tell ASP.NET Core to automatically populate it with data from the submitted form.
    * For model binding to work, the `name` attribute of your HTML input fields must match the property names in your ViewModel (e.g., `name="Employee.Name"` maps to the `Name` property of the `Employee` object within the ViewModel).
* **Anti-Forgery Tokens are Automatic in Razor Pages**
    * Razor Pages automatically enable **Cross-Site Request Forgery (CSRF)** protection for all forms submitted via POST.
    * This is a crucial security feature that ensures the request is coming from your application's own form and not from a malicious site. You don't need to add extra code to enable it for standard POSTs.
* **Using Partial Views for DRY Code**
    * Partial views (like `_EmployeeDetails.cshtml`) are used to create reusable UI components.
    * This follows the **Don't Repeat Yourself (DRY)** principle by allowing you to define a form once and use it in both the "Create" and "Edit" pages.


### Key Interview Takeaways from the Transcript

* **Create a Centralized Error Page for DRY Code**
    * Instead of handling validation errors on every single page, you can create a single, reusable error page (e.g., `Error.cshtml`). This follows the **Don't Repeat Yourself (DRY)** principle.
    * Placing it in a root or shared folder makes it accessible from anywhere in the application.
* **Centralize Logic with a Helper Class**
    * To avoid rewriting the code that extracts errors from `ModelState`, create a `static` helper class (e.g., `ModelStateHelper`).
    * This helper contains a `static` method that takes the `ModelStateDictionary` as input and returns a simple `List<string>` of error messages, making the logic reusable.
```c#
public static class ModelStateHelper
{
    public static List<string> GetErrors(ModelStateDictionary modelState)
    {
        List<string> errorMessages = new List<string>();
        foreach (var value in modelState.Values)
        {
            foreach (var error in value.Errors)
            {
                errorMessages.Add(error.ErrorMessage);
            }
        }

        return errorMessages;
    }
}

```
* **Passing Data During a Redirect using Route Values**
    * When you redirect, you lose your current data. To pass the list of errors to the error page, you include it as a **route value**.
    * The syntax is key: `RedirectToPage("/Error", new { errors = errorList });`
    * This creates a query string in the URL (e.g., `/Error?errors=Name is required&errors=Position is required`), passing the data to the next page.
* **Receiving Data with Model Binding**
    * The `Error.cshtml` page's `OnGet` handler automatically receives the data from the query string through **model binding**.
    * The parameter name in the method must match the key used in the route value: `public void OnGet(List<string> errors)`. The framework automatically populates the `errors` list from the URL.
* **Tag Helpers are a More Modern Alternative**
    * While redirecting to an error page works, the speaker notes a more modern and user-friendly approach is to use **Validation Tag Helpers**.
    * Tag Helpers display error messages directly on the form next to the invalid fields, which is often a better user experience than a full page redirect.



### This code is useful to implement confirmation before Deleting an item

```js
<form 
    name="deleteEmployheeForm" 
    method="post" 
    action="/employees/edit/@Model.EmployeeViewModel.Employee.Id?handler=DeleteEmplopyee">
    @Html.AntiForgeryToken()

    <button type="submit" id="delete-employee" class="btn btn-danger">Delete</button>

</form>


@section scripts
{
    <script>
        document.querySelector("#delete-employee").addEventListener("click",  (event) => {
            event.preventDefault(); // Prevent the default form submission

            const employeeName = '@Model.EmployeeViewModel.Employee.Name';

            const userComfirmation = confirm(`Are you sure you want to delete the employee: ${employeeName}`);

            if (userComfirmation) {
                document.forms["deleteEmployheeForm"].submit();
            }
        });
    </script>
}

```

- Codebehind is as follows:
```c#
public IActionResult OnPostDeleteEmplopyee(int id)
{
    var employee = EmployeesRepository.GetEmployeeById(id);
    if (employee == null)
    {
        ModelState.AddModelError("id", "Employee not found");

        var errors = ModelStateHelper.GetErrors(ModelState);
        return RedirectToPage("/Error", new { errors });
    }

    EmployeesRepository.DeleteEmployee(employee);

    return RedirectToPage("Index");
}
```


